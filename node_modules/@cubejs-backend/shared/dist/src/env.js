"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDockerImage = exports.getEnv = exports.asPortNumber = exports.convertTimeStrToMs = exports.InvalidConfiguration = void 0;
/* eslint-disable no-restricted-syntax */
const env_var_1 = require("env-var");
const cli_1 = require("./cli");
class InvalidConfiguration extends Error {
    constructor(key, value, description) {
        super(`Value "${value}" is not valid for ${key}. ${description}`);
    }
}
exports.InvalidConfiguration = InvalidConfiguration;
function convertTimeStrToMs(input, envName, description = 'Must be number (in seconds) or string in time format (1s, 1m, 1h).') {
    if (/^\d+$/.test(input)) {
        return parseInt(input, 10);
    }
    if (input.length > 1) {
        // eslint-disable-next-line default-case
        switch (input.substr(-1).toLowerCase()) {
            case 'h':
                return parseInt(input.slice(0, -1), 10) * 60 * 60;
            case 'm':
                return parseInt(input.slice(0, -1), 10) * 60;
            case 's':
                return parseInt(input.slice(0, -1), 10);
        }
    }
    throw new InvalidConfiguration(envName, input, description);
}
exports.convertTimeStrToMs = convertTimeStrToMs;
function asPortNumber(input, envName) {
    if (input < 0) {
        throw new InvalidConfiguration(envName, input, 'Should be a positive integer.');
    }
    if (input > 65535) {
        throw new InvalidConfiguration(envName, input, 'Should be lower or equal than 65535.');
    }
    return input;
}
exports.asPortNumber = asPortNumber;
function asPortOrSocket(input, envName) {
    if (/^-?\d+$/.test(input)) {
        return asPortNumber(parseInt(input, 10), envName);
    }
    // @todo Can we check that path for socket is valid?
    return input;
}
function asBoolOrTime(input, envName) {
    if (input.toLowerCase() === 'true') {
        return true;
    }
    if (input.toLowerCase() === 'false' || input === '0') {
        return false;
    }
    return convertTimeStrToMs(input, envName, 'Should be boolean or number (in seconds) or string in time format (1s, 1m, 1h)');
}
let legacyRedisPasswordAlerted = false;
let legacyRedisUrlAlerted = false;
let legacyRedisTlsAlerted = false;
const variables = {
    devMode: () => env_var_1.get('CUBEJS_DEV_MODE')
        .default('false')
        .asBoolStrict(),
    port: () => asPortOrSocket(process.env.PORT || '4000', 'PORT'),
    tls: () => env_var_1.get('CUBEJS_ENABLE_TLS')
        .default('false')
        .asBoolStrict(),
    webSockets: () => env_var_1.get('CUBEJS_WEB_SOCKETS')
        .default('false')
        .asBoolStrict(),
    refreshTimer: () => {
        if (process.env.CUBEJS_SCHEDULED_REFRESH_TIMER) {
            return asBoolOrTime(process.env.CUBEJS_SCHEDULED_REFRESH_TIMER, 'CUBEJS_SCHEDULED_REFRESH_TIMER');
        }
        // Refresh timer is true by default for development
        return process.env.NODE_ENV !== 'production';
    },
    scheduledRefresh: () => env_var_1.get('CUBEJS_SCHEDULED_REFRESH')
        .asBool(),
    gracefulShutdown: () => env_var_1.get('CUBEJS_GRACEFUL_SHUTDOWN')
        .asIntPositive(),
    dockerImageVersion: () => env_var_1.get('CUBEJS_DOCKER_IMAGE_VERSION')
        .asString(),
    // It's only excepted for CI, nothing else.
    internalExceptions: () => env_var_1.get('INTERNAL_EXCEPTIONS_YOU_WILL_BE_FIRED')
        .default('false')
        .asEnum(['exit', 'log', 'false']),
    preAggregationsSchema: () => env_var_1.get('CUBEJS_PRE_AGGREGATIONS_SCHEMA')
        .asString(),
    dbPollTimeout: () => {
        const value = process.env.CUBEJS_DB_POLL_TIMEOUT || '15m';
        return convertTimeStrToMs(value, 'CUBEJS_DB_POLL_TIMEOUT');
    },
    dbPollMaxInterval: () => {
        const value = process.env.CUBEJS_DB_POLL_MAX_INTERVAL || '5s';
        return convertTimeStrToMs(value, 'CUBEJS_DB_POLL_MAX_INTERVAL');
    },
    // Common db options
    dbName: ({ required }) => env_var_1.get('CUBEJS_DB_NAME')
        .required(required)
        .asString(),
    // Export Bucket options
    dbExportBucketType: ({ supported }) => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_TYPE')
        .asEnum(supported),
    dbExportBucket: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET')
        .asString(),
    // Export bucket options for AWS S3
    dbExportBucketAwsKey: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AWS_KEY')
        .asString(),
    dbExportBucketAwsSecret: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AWS_SECRET')
        .asString(),
    dbExportBucketAwsRegion: () => env_var_1.get('CUBEJS_DB_EXPORT_BUCKET_AWS_REGION')
        .asString(),
    // Export bucket options for Integration based
    dbExportIntegration: () => env_var_1.get('CUBEJS_DB_EXPORT_INTEGRATION')
        .asString(),
    // Export bucket options for GCS
    dbExportGCSCredentials: () => {
        const credentials = env_var_1.get('CUBEJS_DB_EXPORT_GCS_CREDENTIALS')
            .asString();
        if (credentials) {
            return JSON.parse(Buffer.from(credentials, 'base64').toString('utf8'));
        }
        return undefined;
    },
    // BigQuery Driver
    bigQueryLocation: () => env_var_1.get('CUBEJS_DB_BQ_LOCATION')
        .asString(),
    // Cube Store
    cubeStoreHost: () => env_var_1.get('CUBEJS_CUBESTORE_HOST')
        .asString(),
    cubeStorePort: () => env_var_1.get('CUBEJS_CUBESTORE_PORT')
        .asPortNumber(),
    cubeStoreUser: () => env_var_1.get('CUBEJS_CUBESTORE_USER')
        .asString(),
    cubeStorePass: () => env_var_1.get('CUBEJS_CUBESTORE_PASS')
        .asString(),
    // Databricks
    databrickUrl: () => env_var_1.get('CUBEJS_DB_DATABRICKS_URL')
        .required()
        .asString(),
    databrickAcceptPolicy: () => env_var_1.get('CUBEJS_DB_DATABRICKS_ACCEPT_POLICY')
        .asString(),
    // Redis
    redisPoolMin: () => env_var_1.get('CUBEJS_REDIS_POOL_MIN')
        .default('2')
        .asInt(),
    redisPoolMax: () => env_var_1.get('CUBEJS_REDIS_POOL_MAX')
        .default('1000')
        .asInt(),
    redisUseIORedis: () => env_var_1.get('CUBEJS_REDIS_USE_IOREDIS')
        .default('false')
        .asBoolStrict(),
    redisPassword: () => {
        const redisPassword = env_var_1.get('CUBEJS_REDIS_PASSWORD')
            .asString();
        if (redisPassword) {
            return redisPassword;
        }
        const legacyRedisPassword = env_var_1.get('REDIS_PASSWORD')
            .asString();
        if (legacyRedisPassword) {
            if (!legacyRedisPasswordAlerted) {
                cli_1.displayCLIWarning('REDIS_PASSWORD is deprecated and will be removed, please use CUBEJS_REDIS_PASSWORD.');
                legacyRedisPasswordAlerted = true;
            }
            return legacyRedisPassword;
        }
        return undefined;
    },
    redisUrl: () => {
        const redisUrl = env_var_1.get('CUBEJS_REDIS_URL')
            .asString();
        if (redisUrl) {
            return redisUrl;
        }
        const legacyRedisUrl = env_var_1.get('REDIS_URL')
            .asString();
        if (legacyRedisUrl) {
            if (!legacyRedisUrlAlerted) {
                cli_1.displayCLIWarning('REDIS_URL is deprecated and will be removed, please use CUBEJS_REDIS_URL.');
                legacyRedisUrlAlerted = true;
            }
            return legacyRedisUrl;
        }
        return undefined;
    },
    redisTls: () => {
        const redisTls = env_var_1.get('CUBEJS_REDIS_TLS')
            .asBoolStrict();
        if (redisTls) {
            return redisTls;
        }
        const legacyRedisTls = env_var_1.get('REDIS_TLS')
            .asBoolStrict();
        if (legacyRedisTls) {
            if (!legacyRedisTlsAlerted) {
                cli_1.displayCLIWarning('REDIS_TLS is deprecated and will be removed, please use CUBEJS_REDIS_TLS.');
                legacyRedisTlsAlerted = true;
            }
            return legacyRedisTls;
        }
        return false;
    },
    dbSsl: () => env_var_1.get('CUBEJS_DB_SSL')
        .default('false')
        .asBoolStrict(),
    dbSslRejectUnauthorized: () => env_var_1.get('CUBEJS_DB_SSL_REJECT_UNAUTHORIZED')
        .default('false')
        .asBoolStrict(),
    nodeEnv: () => env_var_1.get('NODE_ENV')
        .asString(),
    cacheAndQueueDriver: () => env_var_1.get('CUBEJS_CACHE_AND_QUEUE_DRIVER')
        .asString(),
    jwkKey: () => env_var_1.get('CUBEJS_JWK_KEY')
        .asUrlString(),
    jwkUrl: () => env_var_1.get('CUBEJS_JWK_URL')
        .asString(),
    jwtKey: () => env_var_1.get('CUBEJS_JWT_KEY')
        .asString(),
    jwtAlgorithms: () => env_var_1.get('CUBEJS_JWT_ALGS')
        .asArray(','),
    jwtAudience: () => env_var_1.get('CUBEJS_JWT_AUDIENCE')
        .asString(),
    jwtIssuer: () => env_var_1.get('CUBEJS_JWT_ISSUER')
        .asArray(','),
    jwtSubject: () => env_var_1.get('CUBEJS_JWT_SUBJECT')
        .asString(),
    jwtClaimsNamespace: () => env_var_1.get('CUBEJS_JWT_CLAIMS_NAMESPACE')
        .asString(),
    playgroundAuthSecret: () => env_var_1.get('CUBEJS_PLAYGROUND_AUTH_SECRET')
        .asString(),
    agentFrameSize: () => env_var_1.get('CUBEJS_AGENT_FRAME_SIZE')
        .default('200')
        .asInt(),
    telemetry: () => env_var_1.get('CUBEJS_TELEMETRY')
        .default('true')
        .asBool(),
    // Experiments & Preview flags
    livePreview: () => env_var_1.get('CUBEJS_LIVE_PREVIEW')
        .default('false')
        .asBoolStrict(),
    externalDefault: () => env_var_1.get('CUBEJS_EXTERNAL_DEFAULT')
        .default('false')
        .asBoolStrict(),
    scheduledRefreshDefault: () => env_var_1.get('CUBEJS_SCHEDULED_REFRESH_DEFAULT')
        .default('false')
        .asBoolStrict(),
};
function getEnv(key, opts) {
    if (key in variables) {
        return variables[key](opts);
    }
    throw new Error(`Unsupported env variable: "${key}"`);
}
exports.getEnv = getEnv;
function isDockerImage() {
    return Boolean(process.env.CUBEJS_DOCKER_IMAGE_TAG);
}
exports.isDockerImage = isDockerImage;
//# sourceMappingURL=env.js.map